// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "regionRPC.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>


// minisql
#include <iostream>
#include "minisql/Interpreter.h"
#include "minisql/CatalogManager.h"
#include "minisql/RecordManager.h"
#include "minisql/IndexManager.h"
#include <fstream>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "minisql/API.h

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

void init()
{
    FILE *fp;
    fp = fopen("Indexs", "r");
    if (fp == NULL)
    {
        fp = fopen("Indexs", "w+");
        return;
    }
    fclose(fp);
}

void print()
{
    clock_t finish = clock();
    double duration = (double)(finish - start) / CLOCKS_PER_SEC;
    duration *= 1000;
    printf("now time is %2.1f milliseconds\n", duration * 1000);
}

clock_t start;

class regionRPCHandler : virtual public regionRPCIf {
 public:
  regionRPCHandler() {
    // Your initialization goes here
  }

  void send(std::string& _return, const std::string& command) {
    // Your implementation goes here
    printf("send\n");
  }

  void recover(std::string& _return, const std::string& log) {
    // Your implementation goes here
    printf("recover\n");
  }

};

int main(int argc, char **argv) {
    init();

    API api;
    CatalogManager cm;
    RecordManager rm;

    api.rm = &rm;
    api.cm = &cm;
    IndexManager im(&api);

    api.im = &im;
    rm.api = &api;

    start = 0;
    clock_t finish;
    int port = 9090;
    ::std::shared_ptr<regionRPCHandler> handler(new regionRPCHandler());
  ::std::shared_ptr<TProcessor> processor(new regionRPCProcessor(handler));
  ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

